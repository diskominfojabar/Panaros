<!DOCTYPE html>
<html>
<head>
    <title>CIDR Test</title>
</head>
<body>
    <h1>CIDR Matching Test</h1>
    <div id="results"></div>

    <script>
        function isIPv4(str) {
            return /^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$/.test(str);
        }

        function isIPv6(str) {
            return str.includes(':');
        }

        function ipToInt(ip) {
            return ip.split('.').reduce((int, octet) => (int << 8) + parseInt(octet, 10), 0) >>> 0;
        }

        // IPv6 address normalization and expansion
        function normalizeIPv6(ip) {
            ip = ip.replace(/^\[|\]$/g, '');

            if (ip.includes('::')) {
                const sides = ip.split('::');
                const leftGroups = sides[0] ? sides[0].split(':') : [];
                const rightGroups = sides[1] ? sides[1].split(':') : [];
                const missingGroups = 8 - leftGroups.length - rightGroups.length;
                const middleGroups = Array(missingGroups).fill('0000');
                const allGroups = [...leftGroups, ...middleGroups, ...rightGroups];
                ip = allGroups.join(':');
            }

            return ip.split(':').map(g => g.padStart(4, '0')).join(':');
        }

        // Convert IPv6 to BigInt for comparison
        function ipv6ToBigInt(ip) {
            const normalized = normalizeIPv6(ip);
            const groups = normalized.split(':');
            let result = BigInt(0);

            for (let i = 0; i < groups.length; i++) {
                const value = BigInt(parseInt(groups[i], 16));
                result = (result << BigInt(16)) | value;
            }

            return result;
        }

        function isIPInCIDR(ip, cidr) {
            if (!cidr.includes('/')) return false;

            const [range, bits] = cidr.split('/');

            // CRITICAL FIX: Validate both IP and range are same type (IPv4 or IPv6)
            const ipIsV4 = isIPv4(ip);
            const rangeIsV4 = isIPv4(range);

            // Skip if types don't match (prevents IPv4 matching IPv6)
            if (ipIsV4 !== rangeIsV4) {
                return false;
            }

            // Handle IPv4
            if (ipIsV4) {
                const mask = ~(2 ** (32 - parseInt(bits, 10)) - 1);
                return (ipToInt(ip) & mask) === (ipToInt(range) & mask);
            }

            // Handle IPv6
            if (isIPv6(ip) && isIPv6(range)) {
                try {
                    const ipInt = ipv6ToBigInt(ip);
                    const rangeInt = ipv6ToBigInt(range);
                    const prefixLen = parseInt(bits, 10);

                    // Compare first prefixLen bits by shifting right
                    const shift = BigInt(128 - prefixLen);
                    return (ipInt >> shift) === (rangeInt >> shift);
                } catch (e) {
                    console.error('[DEBUG] IPv6 CIDR matching error:', e.message);
                    return false;
                }
            }

            return false;
        }

        function isValidIP(str) {
            const ipRegex = /^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$/;
            if (!ipRegex.test(str)) return false;

            const parts = str.split('.');
            return parts.every(part => {
                const num = parseInt(part, 10);
                return num >= 0 && num <= 255;
            });
        }

        async function testBlacklist() {
            const results = document.getElementById('results');
            const rawInput = '103.125.88.1';
            const isIPQuery = isValidIP(rawInput);

            results.innerHTML += `<p>Testing IP: ${rawInput}</p>`;
            results.innerHTML += `<p>Is valid IP: ${isIPQuery}</p>`;

            try {
                // Fetch blacklist
                const url = 'https://raw.githubusercontent.com/diskominfojabar/Panaros/refs/heads/main/data/blacklist-specific.txt';
                results.innerHTML += `<p>Fetching: ${url}</p>`;

                const response = await fetch(url, { cache: 'no-cache' });
                const text = await response.text();

                results.innerHTML += `<p>Response OK: ${response.ok}</p>`;
                results.innerHTML += `<p>Data length: ${text.length} bytes</p>`;

                // Parse lines
                const lines = text.split('\n');
                results.innerHTML += `<p>Total lines: ${lines.length}</p>`;

                let found = false;
                let matchedLine = '';

                for (let line of lines) {
                    let cleanLine = line.trim();
                    if (cleanLine.startsWith('#') || cleanLine === "") continue;

                    // Extract pattern
                    let pattern;
                    if (cleanLine.includes(' # ')) {
                        pattern = cleanLine.split(' # ')[0].trim();
                    } else {
                        pattern = cleanLine.split(/\s+/)[0];
                    }

                    if (!pattern) continue;
                    pattern = pattern.toLowerCase();

                    // Check CIDR matching
                    let matched = false;
                    if (pattern.includes('/') && isIPQuery) {
                        matched = isIPInCIDR(rawInput, pattern);
                    }

                    if (matched) {
                        found = true;
                        matchedLine = cleanLine;
                        break;
                    }
                }

                if (found) {
                    results.innerHTML += `<h2 style="color: red;">✓ IP BLOCKED!</h2>`;
                    results.innerHTML += `<p>Matched: ${matchedLine}</p>`;
                } else {
                    results.innerHTML += `<h2 style="color: green;">✗ IP NOT BLOCKED</h2>`;
                }

            } catch (e) {
                results.innerHTML += `<p style="color: red;">ERROR: ${e.message}</p>`;
                console.error(e);
            }
        }

        // Run test on load
        window.onload = testBlacklist;
    </script>
</body>
</html>
